!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("mobx"),require("react"),require("react-dom"),require("mobx-react-lite")):"function"==typeof define&&define.amd?define(["exports","mobx","react","react-dom","mobx-react-lite"],t):t((e=e||self).mobxReact={},e.mobx,e.React,e.ReactDOM,e.mobxReactLite)}(this,(function(e,t,r,n,o){"use strict";var i="default"in r?r.default:r;let s=0;const c={};function a(e){return c[e]||(c[e]=function(e){if("function"==typeof Symbol)return Symbol(e);const t=`__$mobx-react ${e} (${s})`;return s++,t}(e)),c[e]}function u(e,t){if(l(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(let n=0;n<r.length;n++)if(!Object.hasOwnProperty.call(t,r[n])||!l(e[r[n]],t[r[n]]))return!1;return!0}function l(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}const f={$$typeof:1,render:1,compare:1,type:1,childContextTypes:1,contextType:1,contextTypes:1,defaultProps:1,getDefaultProps:1,getDerivedStateFromError:1,getDerivedStateFromProps:1,mixins:1,propTypes:1};function p(e,t,r){Object.hasOwnProperty.call(e,t)?e[t]=r:Object.defineProperty(e,t,{enumerable:!1,configurable:!0,writable:!0,value:r})}const b=a("patchMixins"),d=a("patchedDefinition");function y(e,t,...r){t.locks++;try{let n;return null!=e&&(n=e.apply(this,r)),n}finally{t.locks--,0===t.locks&&t.methods.forEach(e=>{e.apply(this,r)})}}function m(e,t){return function(...r){y.call(this,e,t,...r)}}function h(e,t,r){const n=function(e,t){const r=e[b]=e[b]||{},n=r[t]=r[t]||{};return n.locks=n.locks||0,n.methods=n.methods||[],n}(e,t);n.methods.indexOf(r)<0&&n.methods.push(r);const o=Object.getOwnPropertyDescriptor(e,t);if(o&&o[d])return;const i=function e(t,r,n,o,i){let s=m(i,o);return{[d]:!0,get:function(){return s},set:function(i){if(this===t)s=m(i,o);else{const t=e(this,r,n,o,i);Object.defineProperty(this,r,t)}},configurable:!0,enumerable:n}}(e,t,o?o.enumerable:void 0,n,e[t]);Object.defineProperty(e,t,i)}const O=t.$mobx||"$mobx",g=a("isUnmounted"),v=a("skipRender"),w=a("isForcingUpdate");function j(e){const t=e.prototype;if(t.componentWillReact)throw new Error("The componentWillReact life-cycle event is no longer supported");if(e.__proto__!==r.PureComponent)if(t.shouldComponentUpdate){if(t.shouldComponentUpdate!==x)throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.")}else t.shouldComponentUpdate=x;R(t,"props"),R(t,"state");const n=t.render;return t.render=function(){return P.call(this,n)},h(t,"componentWillUnmount",(function(){!0!==o.isUsingStaticRendering()&&(this.render[O]&&this.render[O].dispose(),this[g]=!0)})),e}function P(e){if(!0===o.isUsingStaticRendering())return e.call(this);p(this,v,!1),p(this,w,!1);const n=this.displayName||this.name||this.constructor&&(this.constructor.displayName||this.constructor.name)||"<component>",i=e.bind(this);let s=!1;const c=new t.Reaction(`${n}.render()`,()=>{if(!s&&(s=!0,!0!==this[g])){let e=!0;try{p(this,w,!0),this[v]||r.Component.prototype.forceUpdate.call(this),e=!1}finally{p(this,w,!1),e&&c.dispose()}}});function a(){s=!1;let e=void 0,r=void 0;if(c.track(()=>{try{r=t._allowStateChanges(!1,i)}catch(t){e=t}}),e)throw e;return r}return c.reactComponent=this,a[O]=c,this.render=a,a.call(this)}function x(e,t){return o.isUsingStaticRendering()&&console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."),this.state!==t||!u(this.props,e)}function R(e,r){const n=a(`reactProp_${r}_valueHolder`),o=a(`reactProp_${r}_atomHolder`);function i(){return this[o]||p(this,o,t.createAtom("reactive "+r)),this[o]}Object.defineProperty(e,r,{configurable:!0,enumerable:!0,get:function(){let e=!1;return t._allowStateReadsStart&&t._allowStateReadsEnd&&(e=t._allowStateReadsStart(!0)),i.call(this).reportObserved(),t._allowStateReadsStart&&t._allowStateReadsEnd&&t._allowStateReadsEnd(e),this[n]},set:function(e){this[w]||u(this[n],e)?p(this,n,e):(p(this,n,e),p(this,v,!0),i.call(this).reportChanged(),p(this,v,!1))}})}const S="function"==typeof Symbol&&Symbol.for,E=S?Symbol.for("react.forward_ref"):"function"==typeof r.forwardRef&&r.forwardRef(e=>null).$$typeof,C=S?Symbol.for("react.memo"):"function"==typeof r.memo&&r.memo(e=>null).$$typeof;function U(e){if(!0===e.isMobxInjector&&console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'"),C&&e.$$typeof===C)throw new Error("Mobx observer: You are trying to use 'observer' on function component wrapped to either another observer or 'React.memo'. The observer already applies 'React.memo' for you.");if(E&&e.$$typeof===E){const t=e.render;if("function"!=typeof t)throw new Error("render property of ForwardRef was not a function");return r.forwardRef((function(){return r.createElement(o.Observer,null,()=>t.apply(void 0,arguments))}))}return"function"!=typeof e||e.prototype&&e.prototype.render||e.isReactClass||Object.prototype.isPrototypeOf.call(r.Component,e)?j(e):o.observer(e)}const _=i.createContext({});function k(e){const{children:t,...r}=e,n=i.useContext(_),o=i.useRef({...n,...r});return i.createElement(_.Provider,{value:o.current},t)}function A(e,t,r,n){let o=i.forwardRef((r,n)=>{const o={...r},s=i.useContext(_);return Object.assign(o,e(s||{},o)||{}),n&&(o.ref=n),i.createElement(t,o)});return n&&(o=U(o)),o.isMobxInjector=!0,function(e,t){const r=Object.getOwnPropertyNames(Object.getPrototypeOf(e));Object.getOwnPropertyNames(e).forEach(n=>{f[n]||-1!==r.indexOf(n)||Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))})}(t,o),o.wrappedComponent=t,o.displayName=function(e,t){let r;const n=e.displayName||e.name||e.constructor&&e.constructor.name||"Component";return r=t?"inject-with-"+t+"("+n+")":"inject("+n+")",r}(t,r),o}function $(e){return function(t,r){return e.forEach((function(e){if(!(e in r)){if(!(e in t))throw new Error("MobX injector: Store '"+e+"' is not available! Make sure it is provided by some Provider");r[e]=t[e]}})),r}}k.displayName="MobXProvider";const M=a("disposeOnUnmountProto"),T=a("disposeOnUnmountInst");function q(){[...this[M]||[],...this[T]||[]].forEach(e=>{const t="string"==typeof e?this[e]:e;null!=t&&(Array.isArray(t)?t.map(e=>e()):t())})}function D(e){function r(r,n,o,i,s,c,...a){return t.untracked(()=>(i=i||"<<anonymous>>",c=c||o,null==n[o]?r?new Error("The "+s+" `"+c+"` is marked as required in `"+i+"`, but its value is `"+(null===n[o]?"null":"undefined")+"`."):null:e(n,o,i,s,c,...a)))}const n=r.bind(null,!1);return n.isRequired=r.bind(null,!0),n}function N(e){const t=typeof e;return Array.isArray(e)?"array":e instanceof RegExp?"object":function(e,t){return"symbol"===e||"Symbol"===t["@@toStringTag"]||"function"==typeof Symbol&&t instanceof Symbol}(t,e)?"symbol":t}function I(e,r){return D((n,o,i,s,c)=>t.untracked(()=>{if(e&&N(n[o])===r.toLowerCase())return null;let s;switch(r){case"Array":s=t.isObservableArray;break;case"Object":s=t.isObservableObject;break;case"Map":s=t.isObservableMap;break;default:throw new Error(`Unexpected mobxType: ${r}`)}const a=n[o];if(!s(a)){const t=function(e){const t=N(e);if("object"===t){if(e instanceof Date)return"date";if(e instanceof RegExp)return"regexp"}return t}(a),n=e?" or javascript `"+r.toLowerCase()+"`":"";return new Error("Invalid prop `"+c+"` of type `"+t+"` supplied to `"+i+"`, expected `mobx.Observable"+r+"`"+n+".")}return null}))}function L(e,r){return D((n,o,i,s,c,...a)=>t.untracked(()=>{if("function"!=typeof r)return new Error("Property `"+c+"` of component `"+i+"` has invalid PropType notation.");{let t=I(e,"Array")(n,o,i,s,c);if(t instanceof Error)return t;const u=n[o];for(let e=0;e<u.length;e++)if(t=r(u,e,i,s,c+"["+e+"]",...a),t instanceof Error)return t;return null}}))}const F={observableArray:I(!1,"Array"),observableArrayOf:L.bind(null,!1),observableMap:I(!1,"Map"),observableObject:I(!1,"Object"),arrayOrObservableArray:I(!0,"Array"),arrayOrObservableArrayOf:L.bind(null,!0),objectOrObservableObject:I(!0,"Object")};if(!r.Component)throw new Error("mobx-react requires React to be available");if(!t.observable)throw new Error("mobx-react requires mobx to be available");"function"==typeof n.unstable_batchedUpdates&&t.configure({reactionScheduler:n.unstable_batchedUpdates}),Object.defineProperty(e,"Observer",{enumerable:!0,get:function(){return o.Observer}}),Object.defineProperty(e,"isUsingStaticRendering",{enumerable:!0,get:function(){return o.isUsingStaticRendering}}),Object.defineProperty(e,"useAsObservableSource",{enumerable:!0,get:function(){return o.useAsObservableSource}}),Object.defineProperty(e,"useLocalStore",{enumerable:!0,get:function(){return o.useLocalStore}}),Object.defineProperty(e,"useObserver",{enumerable:!0,get:function(){return o.useObserver}}),Object.defineProperty(e,"useStaticRendering",{enumerable:!0,get:function(){return o.useStaticRendering}}),e.MobXProviderContext=_,e.PropTypes=F,e.Provider=k,e.disposeOnUnmount=function e(t,r){if(Array.isArray(r))return r.map(r=>e(t,r));const n=Object.getPrototypeOf(t).constructor||Object.getPrototypeOf(t.constructor),o=Object.getPrototypeOf(t.constructor);if(n!==i.Component&&n!==i.PureComponent&&o!==i.Component&&o!==i.PureComponent)throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");if("string"!=typeof r&&"function"!=typeof r&&!Array.isArray(r))throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");const s=!!t[M]||!!t[T];return("string"==typeof r?t[M]||(t[M]=[]):t[T]||(t[T]=[])).push(r),s||h(t,"componentWillUnmount",q),"string"!=typeof r?r:void 0},e.inject=function(...e){if("function"==typeof arguments[0]){let e=arguments[0];return t=>A(e,t,e.name,!0)}return t=>A($(e),t,e.join("-"),!1)},e.observer=U,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=mobxreact.umd.production.min.js.map
